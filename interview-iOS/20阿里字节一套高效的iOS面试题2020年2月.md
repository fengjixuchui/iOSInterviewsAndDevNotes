# 阿里字节一套高效的iOS面试题2020年2月

> 作者：Monkery

> 鏈接：https://juejin.im/post/5e397ccaf265da570b3f1b02

- 笔者最近收集梳理了一些iOS相关的问题，其中大部分都是大厂面试或者面试其他人用到的，能命中大部分的面试和日常工作，更希望你可以用它来检验自己
- 此篇问题，有一部分和之前的部分题目有很多重合，类似的，可以借鉴参考。

## runtime相关问题

>  runtime是iOS开发最核心的知识了，如果下面的问题都解决了，那么对runtime的理解已经很深了。 runtime已经开源了，官网[objc4](https://opensource.apple.com/tarballs/objc4/)


### 结构模型

### 介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

<details>
<summary> 参考内容 </summary>

- 对象：OC中的对象指向的是一个objc_object指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个isa指针，指向的是这个对象的类对象,一个对象实例就是通过这个isa找到它自己的Class，而这个Class中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- 类：在OC中的类是用Class来表示的，实际上它指向的是一个objc_class的指针类型，typedef struct objc_class *Class
- OC的Class类型包括如下数据（即：元数据metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
- 当然也包括一个isa指针，这说明Class也是一个对象类型，所以我们称之为类对象，这里的isa指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。

- OC对象、类、元类之间的关系

![参考图示](https://ucc.alicdn.com/pic/developer-ecology/d237d2810b0442f4a697f5bcf0707980.png)

</details>

### 为什么要设计metaclass

* 类对象、元类对象能够复用消息发送流程机制；
* 单一职责原则

###  class_copyIvarList & class_copyPropertyList区别

<details>
<summary> 参考内容 </summary>

>  property 正常使用会生成对应的实例变量，所以 `Ivar` 可以查到。

- class_copyIvarList 获取类对象中的所有实例变量信息，从 `class_ro_t` 中获取：

- class_copyPropertyList 获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。
-  可参考如下代码

```
Ivar *
class_copyIvarList(Class cls, unsigned int *outCount)
{
    const ivar_list_t *ivars;
    Ivar *result = nil;
    unsigned int count = 0;

    if (!cls) {
        if (outCount) *outCount = 0;
        return nil;
    }

    mutex_locker_t lock(runtimeLock);

    assert(cls->isRealized());
    
    if ((ivars = cls->data()->ro->ivars)  &&  ivars->count) {
        result = (Ivar *)malloc((ivars->count+1) * sizeof(Ivar));
        
        for (auto& ivar : *ivars) {
            if (!ivar.offset) continue;  // anonymous bitfield
            result[count++] = &ivar;
        }
        result[count] = nil;
    }
    
    if (outCount) *outCount = count;
    return result;
}

objc_property_t *
class_copyPropertyList(Class cls, unsigned int *outCount)
{
    if (!cls) {
        if (outCount) *outCount = 0;
        return nil;
    }

    mutex_locker_t lock(runtimeLock);

    checkIsKnownClass(cls);
    assert(cls->isRealized());
    
    auto rw = cls->data();

    property_t **result = nil;
    unsigned int count = rw->properties.count();
    if (count > 0) {
        result = (property_t **)malloc((count + 1) * sizeof(property_t *));

        count = 0;
        for (auto& prop : rw->properties) {
            result[count++] = &prop;
        }
        result[count] = nil;
    }

    if (outCount) *outCount = count;
    return (objc_property_t *)result;
}
```

### class_rw_t 和 class_ro_t 的区别

- class_rw_t 
	-  class_ro_t
	-  Protocols
	-  MethodLists
	-  Properties

- class_rw_t 中的 properties 属性按顺序包含分类/扩展/基类中的属性。

```
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;
    
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};

struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;

#if SUPPORT_INDEXED_ISA
    uint32_t index;
#endif
}

```
</details>

### category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序

<details>
<summary> 参考内容 </summary>

- +load 方法是 images 加载的时候调用，假设有一个 XXXClass 类，其主类和所有分类的 `+load` 都会被调用，**优先级是先调用主类**，且如果主类有继承链，那么加载顺序还必须是基类的 `+load` ，接着是父类，最后是子类；category 的 `+load` 则是按照**编译顺序**来的，先编译的先调用，后编译的后调用，可在 Xcode  的 BuildPhase 中查看
	- 分类添加到了 `rw = cls->data()` 中的 `methods/properties/protocols` 中，实际上并无`覆盖`，只是查找到就返回了，导致本类函数无法加载。

</details>

### initialize && Load

<details>
<summary> 参考内容 </summary>

- **类第一次被使用到的时候会被调用**，底层实现有个逻辑先判断父类是否被初始化过，没有则先调用父类，然后在调用当前类的 initialize 方法.
	- 一个类 A 存在多个 category ，且 category中各自实现了 initialize 方法，这时候走的是 **消息发送流程**，**也就说 initialize 方法只会调用一次，也就是最后编译的那个category中的 initialize 方法。**

- 如果+load 方法中调用了其他类：比如 B 的某个方法，其实就是走消息发送流程，由于 B 没有初始化过，则会调用其 initialize 方法，但此刻 B 的 +load 方法可能还没有被系统调用过。

#####  不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 `[super load]` 或者 `[super initialize]` 方法，实际上是走消息发送流程，那么这里也涉及了一个调用流程，需要引起注意。

</details>

### category & extension区别，能给NSObject添加Extension吗，结果如何

- 不可以为系统类添加扩展

### 在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么

<details>
<summary> 参考内容 </summary>

- OC中的方法调用，编译后的代码最终都会转成 `objc_msgSend(id , SEL, ...)` 方法进行调用，
- 这个方法第一个参数是一个消息接收者对象，runtime通过这个对象的isa指针找到这个对象的类对象，从类对象中的cache中查找(**哈希查找，bucket 桶实现**)是否存在SEL对应的IMP，若不存在，则会在 method_list中查找（二分查找或者顺序查找），如果还是没找到，则会到supper_class中查找，仍然没找到的话，就会调用_objc_msgForward(id, SEL, ...)进行消息转发。

</details>

### IMP、SEL、Method的区别和使用场景
<details>
<summary> 参考内容 </summary>

- [面试题第三份基础概念参考](03interview-iOS-3.md)

```
typedef struct method_t *Method;

using MethodListIMP = IMP;

struct method_t {
    SEL name;
    const char *types;
    MethodListIMP imp;
};
```
</details>

### load、initialize方法的区别什么？在继承关系中他们有什么区别

<details>
<summary> 参考内容 </summary>

> 程序启动 -> load(自动调用) -> [XXAudioTool loadData] ->initialize(自动调用) ->loadData

- load 方法调用时机，而且只调用当前类本身，不会调用superClass 的 `+load` 方法：
	- 和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。
-  ` callInitialize(cls)` 然后又调用了 `lockAndFinishInitializing(cls, supercls)`。 
</details>

### 说说消息转发机制的优劣
<details>
<summary> 参考内容 </summary>

- 消息转发
	- 消息转发机制（可以间接实现多重继承）
	- methodSignatureForSelector:的处理使得NSNull对象可以接受任何 selector 而不产生doesNotRecognizeSelector:异常
	- forwardInvocation:的处理使得NSNull实例接受到 unknown selector 时，不做任何处理，即空操作

- 动态方法解析	
</details>


### 内存管理

###  weak的实现原理？SideTable的结构是什么样的

- [weak修饰的释放则自动被置为nil的实现原理](./02interview-iOS-2.md)
- [weak弱引用的代码逻辑实现?](./03interview-iOS-3.md)

<details>
<summary> SideTable参考内容 </summary>

- SideTable 结构体在 runtime 底层用于引用计数和弱引用关联表，其数据结构是这样：
	- 指向某个对象A的所有  weak 关键字修饰的引用都 append 到 `weak_entry_t` 结构体中的`referrers`， 同时`weak_entry_t` 的 `referent` 就是对象A，之后在dealloc 释放时遍历 `weak_table` 遍历时会判断 referent 是否为对象 A 取到 `weak_entry_t`，加入到该 SideTable 中 `weak_table` 中：

```c++
struct SideTable {

    spinlock_t slock;

    RefcountMap refcnts;

    weak_table_t weak_table;
}

struct weak_table_t {
    // 保存了所有指向指定对象的 weak 指针
    weak_entry_t *weak_entries;
    // 存储空间
    size_t    num_entries;
    // 参与判断引用计数辅助量
    uintptr_t mask;
    // hash key 最大偏移值
    uintptr_t max_hash_displacement;
};

```

```

id objc_initWeakOrNil(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak<DontHaveOld, DoHaveNew, DontCrashIfDeallocating>
        (location, (objc_object*)newObj);
}
```
</details>

###  关联对象的应用？系统如何实现关联对象的

> [应用实例代码：为UIView及子类新增点击事件Block回调处理](https://github.com/DevDragonLi/iOSDevDemo/blob/master/1-DevDemo/PodPrivate_demo/Pods/JueJinBasedComponent/JueJinBasedComponent/Classes/UIKit/UIView/UIView%2BXTHelper.m)

- [本系列面试题第八份参考：关联对象](08字节跳动面试题：2018年4月.md)

<details>
<summary> SideTable参考内容 </summary>

- 置空关联对象：赋值给与nil即可

```c++
id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        // manager.associations()  `AssociationsHashMap` 对象(*_map)
        AssociationsHashMap &associations(manager.associations());
        // intptr_t 是为了兼容平台，在64位的机器上，intptr_t和uintptr_t分别是long int、unsigned long int的别名；在32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名
        // DISGUISE 内部对指针做了 ~ 取反操作
        disguised_ptr_t disguised_object = DISGUISE(object);
        /*
         AssociationsHashMap 继承自 unordered_map，存储 key-value 的组合
         iterator find ( const key_type& key )，如果 key 存在，则返回key对象的迭代器，
         如果key不存在，则find返回 unordered_map::end；因此可以通过 `map.find(key) == map.end()`
         判断 key 是否存在于当前 map 中。
         */
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            /*
                unordered_map 的键值分别是迭代器的first和second属性。
                所以说上面先通过 object 对象(实例对象or类对象) 找到其所有关联对象
                i->second 取到又是一个 ObjectAssociationMap
                此刻再通过我们自己设定的 key 来查找对应的关联属性值，不过使用
                `ObjcAssociation` 封装的
             */
            ObjectAssociationMap *refs = i->second;
            ObjectAssociationMap::iterator j = refs->find(key);
            if (j != refs->end()) {
                ObjcAssociation &entry = j->second;
                value = entry.value();
                policy = entry.policy();
                // 平常 OBJC_ASSOCIATION_RETAIN = 01401
                // OBJC_ASSOCIATION_GETTER_RETAIN = (1 << 8)
                if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) {

                    objc_retain(value);
                }
            }
        }
    }
    if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    return value;
}


void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    ObjcAssociation old_association(0, nil);
    // 如果value对象存在，则进行retain or copy 操作
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        // manager.associations()  `AssociationsHashMap` 对象(*_map)
        AssociationsHashMap &associations(manager.associations());
        // intptr_t 是为了兼容平台，在64位的机器上，intptr_t和uintptr_t分别是long int、unsigned long int的别名；在32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名
        // DISGUISE 内部对指针做了 ~ 取反操作
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            /*
             AssociationsHashMap 继承自 unordered_map，存储 key-value 的组合
             iterator find ( const key_type& key )，如果 key 存在，则返回key对象的迭代器，
             如果key不存在，则find返回 unordered_map::end；因此可以通过 `map.find(key) == map.end()`
             判断 key 是否存在于当前 map 中。
             */
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            // 这里和get操作不同，set操作时如果查询到对象没有关联对象，那么这一次设值是第一次，
            // 所以会创建一个新的 ObjectAssociationMap 用来存储实例对象的所有关联属性
            if (i != associations.end()) {
                // secondary table exists
                /*
                    unordered_map 的键值分别是迭代器的first和second属性。
                    所以说上面先通过 object 对象(实例对象or类对象) 找到其所有关联对象
                    i->second 取到又是一个 ObjectAssociationMap
                    此刻再通过我们自己设定的 key 来查找对应的关联属性值，不过使用
                    `ObjcAssociation` 封装的
                 */
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                // 关联属性用 ObjcAssociation 结构体封装
                if (j != refs->end()) {
                    old_association = j->second;
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                // 知识点是：newisa.has_assoc = true;
                object->setHasAssociatedObjects();
            }
        } else {
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    if (old_association.hasValue()) ReleaseValue()(old_association);
}

```
</details>

###  关联对象的如何进行内存管理的？关联对象如何实现weak属性

<details>
<summary> 参考内容 </summary>

- 使用了 `policy` 设置内存管理策略
	- OBJC_ASSOCIATION_ASSIGN类型的关联对象和`weak`有一定差别，而更加接近于`unsafe_unretained`，即当目标对象遭到摧毁时，属性值不会自动清空。

- 然后内部封装一个 `weak` 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil操作
</details>

###  Autoreleasepool的原理？所使用的的数据结构是什么

<details>
<summary> 参考内容 </summary>

- 基于栈为节点（node）的双向链表
- 使用 `@autoreleasePool` 包裹的作用域中，所有调用 autorelease 都会将对象push到自动释放池，作用域结束就会drain一次，这里涉及到了 哨兵对象，也就是 插入一个nil标识。

</details>

###  ARC的实现原理？ARC下对retain & release做了哪些优化
- [本系列面试题第三份参考：ARC的实现原理](03interview-iOS-3.md)

###  ARC下哪些情况会造成内存泄漏

<details>
<summary> 参考内容 </summary>

* 循环引用;
* CF类型内存/C语言malloc出来的对象
* 单例也会造成内存泄漏
	* 可以根据项目需求设置为可销毁对象

</details>

### 其他

1. Method Swizzle注意事项
1. 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗
1. iOS 中内省的几个方法有哪些？内部实现原理是什么
1. class、objc_getClass、object_getclass 方法有什么区别?

### NSNotification相关

> 认真研读、你可以在这里找到答案轻松过面：[一文全解iOS通知机制(经典收藏)](https://juejin.im/post/5e5fc16df265da575155723b)

1. 实现原理（结构设计、通知如何存储的、name&observer&SEL之间的关系等）
1. 通知的发送时同步的，还是异步的
1. NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息
1. NSNotificationQueue是异步还是同步发送？在哪个线程响应
1. NSNotificationQueue和runloop的关系
1. 如何保证通知接收的线程在主线程
1. 页面销毁时不移除通知会崩溃吗
1. 多次添加同一个通知会是什么结果？多次移除通知呢
1. 下面的方式能接收到通知吗？为什么

	```objc
	// 发送通知
	[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@"TestNotification" object:@1];
	// 接收通知
	[NSNotificationCenter.defaultCenter postNotificationName:@"TestNotification" object:nil];
	
	```	

### runloop

1. app如何接收到触摸事件的
1. 为什么只有主线程的runloop是开启的
1. 为什么只在主线程刷新UI
1. PerformSelector和runloop的关系
1. 如何使线程保活

### KVO


1. 实现原理
1. 如何手动关闭kvo
1. 通过KVC修改属性会触发KVO么
1. 哪些情况下使用kvo会崩溃，怎么防护崩溃
1. kvo的优缺点

### Block

1. block的内部实现，结构体是什么样的
1. block是类吗，有哪些类型
1. 一个int变量被 __block 修饰与否的区别？block的变量截获
1. block在修改NSMutableArray，需不需要添加__block
1. 怎么进行内存管理的
1. block可以用strong修饰吗
1. 解决循环引用时为什么要用__strong、__weak修饰
1. block发生copy时机
1. Block访问对象类型的auto变量时，在ARC和MRC下有什么区别

### 多线程
> 主要以GCD为主

1. iOS开发中有多少类型的线程？分别对比
1. GCD有哪些队列，默认提供哪些队列
1. GCD有哪些方法api
1. GCD主线程 & 主队列的关系
1. 如何实现同步，有多少方式就说多少
1. dispatch_once实现原理
1. 什么情况下会死锁
1. 有哪些类型的线程锁，分别介绍下作用和使用场景
1. NSOperationQueue中的maxConcurrentOperationCount默认值
1. NSTimer、CADisplayLink、dispatch_source_t 的优劣

### 视图&图像相关

1. AutoLayout的原理，性能如何
1. UIView & CALayer的区别
1. 事件响应链
1. drawrect & layoutsubviews调用时机
1. UI的刷新原理
1. 隐式动画 & 显示动画区别
1. 什么是离屏渲染
1. imageName &  imageWithContentsOfFile区别
1. 多个相同的图片，会重复加载吗
1. 图片是什么时候解码的，如何优化
1. 图片渲染怎么优化
1. 如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决

### 性能优化

1. 如何做启动优化，如何监控
1. 如何做卡顿优化，如何监控
1. 如何做耗电优化，如何监控
1. 如何做网络优化，如何监控

### 开发证书

1. 苹果使用证书的目的是什么
1. AppStore安装app时的认证流程
1. 开发者怎么在debug模式下把app安装到设备呢

### 架构设计
> 典型源码的学习

> 只是列出一些iOS比较核心的开源库，这些库包含了很多高质量的思想，源码学习的时候一定要关注每个框架解决的核心问题是什么，还有它们的优缺点，这样才能算真正理解和吸收

1. AFN
1. SDWebImage
1. JSPatch、Aspects(虽然一个不可用、另一个不维护，但是这两个库都很精炼巧妙，很适合学习)
1. Weex/RN, 笔者认为这种前端和客户端紧密联系的库是必须要知道其原理的
1. CTMediator、其他router库，这些都是常见的路由库，开发中基本上都会用到

### 架构设计

1. 手动埋点、自动化埋点、可视化埋点
1. MVC、MVP、MVVM设计模式
1. 常见的设计模式
1. 单例的弊端
1. 常见的路由方案，以及优缺点对比
1. 如果保证项目的稳定性
1. 设计一个图片缓存框架(LRU)
1. 如何设计一个git diff
1. 设计一个线程池？画出你的架构图
1. 你的app架构是什么，有什么优缺点、为什么这么做、怎么改进

### 其他问题

1. PerformSelector & NSInvocation优劣对比
1. oc怎么实现多继承？怎么面向切面[（可以参考Aspects深度解析-iOS面向切面编程）](https://juejin.im/post/5e13c4366fb9a047f42e6406)
1. 哪些bug会导致崩溃，如何防护崩溃
1. 怎么监控崩溃
1. app的启动过程（考察LLVM编译过程、静态链接、动态链接、runtime初始化）
1. 沙盒目录的每个文件夹划分的作用
1. 简述下match-o文件结构

### 系统基础知识

1. 进程和线程的区别
1. HTTPS的握手过程
1. 什么是中间人攻击？怎么预防
1. TCP的握手过程？为什么进行三次握手，四次挥手
1. 堆和栈区的区别？谁的占用内存空间大
1. 加密算法：对称加密算法和非对称加密算法区别
1. 常见的对称加密和非对称加密算法有哪些
1. MD5、Sha1、Sha256区别
1. charles抓包过程？不使用charles，4G网络如何抓包

### 数据结构与算法
> 对于移动开发者来说，一般不会遇到非常难的算法，大多以数据结构为主，笔者列出一些必会的算法，当然有时间了可以去LeetCode上刷刷题

1. 八大排序算法
1. 栈&队列
1. 字符串处理
1. 链表
1. 二叉树相关操作
1. 深搜广搜
1. 基本的动态规划题、贪心算法、二分查找



## 链接

- [面试题系列目录](../README.md)
- **上一份**: [新浪公司iOS面试题2019年6月](19新浪公司iOS面试题2019年6月.md)
- **下一份**: [出一套iOS高级面试题J_Knight_](21出一套iOS高级面试题2018年7月.md)
